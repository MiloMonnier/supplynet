% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/robustness.R
\name{robustnessGraph}
\alias{robustnessGraph}
\title{Analysis of supply network robustness}
\usage{
robustnessGraph(
  g,
  type = c("vertices", "edges"),
  vs = V(g)[V(g)$type == "I"],
  es = E(g),
  mode = c("random", "targeted"),
  metric.FUN = SAR,
  niter = Inf,
  ...
)
}
\arguments{
\item{g}{igraph; a supply network where every node has a 'type'
attribute which can be "P" (producer), "I" (intermediary), or "D" (distributor).}

\item{type}{character string; either 'vertices' or 'edges' removals.
(default: 'vertices').}

\item{vs}{igraph.vs; used if type='vertices', the vertices which can be deleted.
(default: only intermediaries).}

\item{es}{igraph.es; used if type='edges', the edges which can be deleted.
(default: all graph edges).}

\item{mode}{character; how to choose the vertex or the edge to delete, either
'random' or 'targeted'. If 'targeted', the v or e with highest betweenness
is selected (default: 'random').}

\item{metric.FUN}{function; critical supply network metric to recompute at
Each time step. (default: \code{\link{SAR}}).}

\item{niter}{numeric; maximal number of removals (default: infinite).}

\item{...}{if mode='targeted', other arguments can be passed to
\code{\link{getVertices}}, or \code{\link{getEdges}} functions. Example:
\itemize{
  \item if type='vertices' and ct.ind.FUN=\code{betweenness}, we target the
  vertex with highest betweenness.
  \item if type='edges' and ct.ind.FUN=\code{edge_betweenness}, we target
  the edge with highest betweenness.
  \item type='edges' and ct.ind.FUN=\code{betweenness} does not work.
}}
}
\value{
numeric between 0 and 1. The mean of \code{metric.FUN} over iterations.
}
\description{
This function performs a "targeted attack" of a graph or a "random failure"
analysis, calculating a tunable critical metric of the supply network after
successive edge or vertex removals. Attacks can target a vertex or an edge
according to different centrality indices.
}
\details{
At each time step, a vertex or an edge is deleted from the supply network.
Then, vertices isolated are also deleted (cascading failures), and critical
metric is recomputed. Process stops if:
* all graph elements has been deleted.
* critical metrics reached 0.
* maximal number of iterations has been reached
}
\examples{
## Generate a theoretical supply network, define producers (P),
## Intermediaries (I) and distributors (D) vertices.
library(igraph)
set.seed(123)
g = make_tree(20)
V(g)[!degree(g, mode="in")]$type = "P"
V(g)[degree(g, mode="in") & degree(g, mode="in")]$type = "I"
V(g)[!degree(g, mode="out")]$type = "D"
V(g)$color = c("green","red","yellow")[factor(V(g)$type, levels=c("P","I","D"))]
## Vertices robustness
robustnessGraph(g, type="v") # Random failures
robustnessGraph(g, type="v", mode="targ", ct.ind.FUN=betweenness) # Betweenness targeted attacks
robustnessGraph(g, type="v", mode="targ", ct.ind.FUN=degree) # Degree targeted
## Edges robustness
robustnessGraph(g, type="e")  # Random failures
robustnessGraph(g, type="e", mode="targ") # Betweenness targeted attacks

}
\seealso{
Improves \code{\link[brainGraph:robustness]{brainGraph:robustness}} with more
modularity in the choice of centrality index and critical metric.
See https://github.com/cran/brainGraph/blob/master/R/robustness.R
}
